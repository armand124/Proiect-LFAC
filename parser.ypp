%code requires {
    #include <iostream>
    #include <string>
    #include <cstring>
    #include <vector>
    #include "SymbolTable.h"
    #include "helper.h"
    #include "AbstractSyntaxTree.h"
}

%{
    #include <iostream>
    #include <string>
    #include <cstring>
    #include <vector>
    #include <fstream>
    #include "SymbolTable.h"
    #include "helper.h"
    #include "AbstractSyntaxTree.h"

    #define YYDEBUG 1 
    
    extern int yylex();
    extern int yylineno;
    extern char* yytext;
    void yyerror(const char *s);

    SymbolTable* currentScope = nullptr , *globalScope = nullptr;
    std::map < std::string , SymbolTable* > classes;
   
%}

%union {
    int val_int;
    float val_float;
    std::string* Str;
    std::vector<ParamInfo>* Params;
    std::vector < ASTnode* > *Args;
    ASTnode *node;
}


%token <Str> ID TYPE
%token <val_int> INT_CONST BOOL_CONST
%token <val_float> FLOAT_CONST
%token <Str> STRING_CONST
%token KEYWORD_CLASS KEYWORD_FUNC KEYWORD_IF KEYWORD_MAIN KEYWORD_RETURN KEYWORD_WHILE KEYWORD_FOR KEYWORD_PRINT KEYWORD_DEFINE KEYWORD_THEN
%token ADD_OP SUB_OP MUL_OP DIV_OP ASSIGN_OP MOD_OP EQ_OP NEQ_OP LT_OP GT_OP GEQ_OP LEQ_OP
%token OP_AND OP_OR OP_BIT_AND OP_BIT_OR OP_BIT_XOR OP_BIT_LSHIFT OP_BIT_RSHIFT NOT_OP
%token OPEN_ROUND_PAR CLOSED_ROUND_PAR OPEN_RECTANGLE_PAR CLOSED_RECTANGLE_PAR
%token OPEN_CURLY_BRACE CLOSED_CURLY_BRACE SEMICOLON DOT COMMA DOLLA_SIGN

%type <Str> type_specifier
%type <Params> func_params
%type <node> expression expression_base
%type <node> func_call
%type <Args> call_args
%type <node> statement
%type <node> statement_list statement_block
%type <node> print_stmt
%type <node> assignment lvalue
%type <node> constructor_decl variable_decl

%right ASSIGN_OP
%left OP_OR
%left OP_AND
%left OP_BIT_OR
%left OP_BIT_XOR
%left OP_BIT_AND
%left EQ_OP NEQ_OP
%left LT_OP GT_OP GEQ_OP LEQ_OP
%left OP_BIT_LSHIFT OP_BIT_RSHIFT
%left ADD_OP SUB_OP
%left MUL_OP DIV_OP MOD_OP
%right NOT_OP UMINUS
%left DOT OPEN_RECTANGLE_PAR OPEN_ROUND_PAR
%left COMMA 

%start program

%%

program:
    { 
        currentScope = globalScope = new SymbolTable("Global"); 
        yylineno = 1;
    } global_declarations main_block
;

global_declarations:
    | global_declarations class_decl
    | global_declarations func_decl
    | global_declarations variable_decl
;

class_decl:
    KEYWORD_DEFINE KEYWORD_CLASS ID 
    { 
        SymbolTable *class_scope = SymbolTable::class_lookup(*$3 , classes);

        if(class_scope != nullptr)
        {
            std::cout << yylineno << ": " << "Class already defined: " << *$3;
            exit(1);
        }

        currentScope->addVar("class", *$3, "class", nullptr);
        currentScope = new SymbolTable(*$3, currentScope);
        classes[*$3] = currentScope;
        
        SymbolTable::addClass(*$3, currentScope);
    }
    OPEN_CURLY_BRACE class_body CLOSED_CURLY_BRACE
    { 
        currentScope = currentScope->getParent();
    }
;

class_body:
    | class_body field_decl
    | class_body method_decl
    | class_body constructor_decl
;

constructor_decl:
    KEYWORD_DEFINE KEYWORD_FUNC ID
    {
         if (*$3 != currentScope->get_scope_name()) {
             std::cout << yylineno << ": Constructor name " << *$3 << " must match class name " << currentScope->get_scope_name() << std::endl;
             exit(1);
         }
         
         currentScope->addVar("void", "constructor", "function", nullptr, nullptr); 
         currentScope = new SymbolTable("constructor", currentScope);
    }
    statement_block 
    {
        currentScope = currentScope->getParent();
        IdInfo* ctor = currentScope->lookup("constructor");
        if (ctor) ctor->body = $5;
    }
;

field_decl:
    KEYWORD_DEFINE type_specifier ID SEMICOLON
    { 
        currentScope->addVar(*$2, *$3, "field", nullptr);
    }
;

method_decl:
    KEYWORD_DEFINE KEYWORD_FUNC type_specifier ID OPEN_ROUND_PAR func_params CLOSED_ROUND_PAR
    { 
        currentScope->addVar(*$3, *$4, "function", $6);
        currentScope = new SymbolTable(*$4, currentScope);
        if ($6) {
           for (const auto& param : *$6) {
               currentScope->addVar(param.type, param.name, "param", nullptr);
           }
        }
    }
    statement_block
    { 
        SymbolTable* funcScope = currentScope;
        currentScope = currentScope->getParent();
        
        IdInfo* func = currentScope->lookup(*$4);
        if (func) {
             func->body = $9;
             func->scope = funcScope;
        }
    }
;

func_decl:
    KEYWORD_DEFINE KEYWORD_FUNC type_specifier ID OPEN_ROUND_PAR func_params CLOSED_ROUND_PAR
    { 
        currentScope->addVar(*$3, *$4, "function", $6);
        currentScope = new SymbolTable(*$4, currentScope);
        if ($6) {
           for (const auto& param : *$6) {
               currentScope->addVar(param.type, param.name, "param", nullptr);
           }
        }
    }
    statement_block
    { 
        SymbolTable* funcScope = currentScope;
        currentScope = currentScope->getParent();
        
        IdInfo* func = currentScope->lookup(*$4);
        if (func) {
             func->body = $9;
             func->scope = funcScope;
        }
    }
;

func_params:
    { $$ = new std::vector<ParamInfo>(); }
    |
    type_specifier DOLLA_SIGN ID
    {
        $$ = new std::vector<ParamInfo>();
        $$->push_back(ParamInfo(*$1, *$3));
    }
    |
    func_params COMMA type_specifier DOLLA_SIGN ID
    {
        $$ = $1;
        $$->push_back(ParamInfo(*$3, *$5));
    }
;
main_block:
    KEYWORD_MAIN 
    { 
        currentScope = new SymbolTable("main", currentScope);
    }
    statement_block
    { 
        if ($3) $3->evaluate();
        
        currentScope = currentScope->getParent();
    }
;


statement_block:
    OPEN_CURLY_BRACE statement_list CLOSED_CURLY_BRACE { $$ = $2; }
;

statement_list:
    { $$ = nullptr; }
    | statement_list statement
    {
        if ($1 == nullptr) $$ = $2;
        else $$ = new ASTnode($1, Data(TYPE::CHAR, OP::SEQ_), $2, new std::string("VOID"));
    }
;




variable_decl:
    KEYWORD_DEFINE type_specifier ID SEMICOLON
    { 
        currentScope->addVar(*$2, *$3, "variable", nullptr);
        ASTnode* typeNode = new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$2)), nullptr, new std::string("STRING"));
        ASTnode* nameNode = new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$3)), nullptr, new std::string("STRING"));
        $$ = new ASTnode(typeNode, Data(TYPE::CHAR, OP::DECL_), nameNode, new std::string("VOID"));
    }
    | KEYWORD_DEFINE type_specifier ID COMMA ID SEMICOLON
    {
         currentScope->addVar(*$2, *$3, "variable", nullptr);
         currentScope->addVar(*$2, *$5, "variable", nullptr);
         
         ASTnode* typeNode = new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$2)), nullptr, new std::string("STRING"));
         ASTnode* name1 = new ASTnode(typeNode, Data(TYPE::CHAR, OP::DECL_), new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$3)), nullptr, new std::string("STRING")), new std::string("VOID"));
         ASTnode* name2 = new ASTnode(typeNode, Data(TYPE::CHAR, OP::DECL_), new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$5)), nullptr, new std::string("STRING")), new std::string("VOID"));
         $$ = new ASTnode(name1, Data(TYPE::CHAR, OP::SEQ_), name2, new std::string("VOID"));
    }
;

statement:
    assignment SEMICOLON { $$ = $1; }
    | variable_decl { $$ = $1; } 
    | KEYWORD_IF expression KEYWORD_THEN statement_block 
    {
         $$ = nullptr; 
    }
    | KEYWORD_IF expression KEYWORD_THEN statement_block KEYWORD_IF KEYWORD_THEN statement_block { $$ = nullptr; } 
    
    | KEYWORD_WHILE expression statement_block {$$ = nullptr;}
    | KEYWORD_FOR assignment SEMICOLON expression SEMICOLON assignment statement_block {$$ = nullptr;}
    | KEYWORD_RETURN expression SEMICOLON 
    {
        SymbolTable* scope = currentScope;
        IdInfo* funcInfo = nullptr;
        if (scope->getParent()) {
            funcInfo = scope->getParent()->lookup(scope->get_scope_name());
        }
        
        if (funcInfo && funcInfo->category == "function") {
             std::string retType = funcInfo->return_type;
             std::string exprType = $2->get_type();
             
             if (retType == "VOID" || retType == "void") {
                 std::cout << yylineno << ": Void function '" << funcInfo->name << "' cannot return a value." << std::endl;
                 exit(1);
             }
             
             if (retType != exprType) {
                  std::cout << yylineno << ": Return type mismatch in function '" << funcInfo->name << "'. Expected " << retType << ", got " << exprType << std::endl;
                  exit(1);
             }
        }
        
        $$ = new ASTnode($2, Data(TYPE::CHAR, OP::RET_), nullptr, $2->get_type_ptr());
    }
    | print_stmt { $$ = $1; }
    | func_call SEMICOLON { $$ = $1; }
    | statement_block { $$ = $1; }
;

lvalue:
    ID
    {
        IdInfo *id_info = currentScope -> lookup(*$1);
        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$1;
            exit(1);
        }
        $$ = new ASTnode(nullptr , Data(TYPE::ID_INFO , id_info) , nullptr , new std::string(id_info -> type));
    }
    | lvalue DOT ID
    {
        ASTnode* left = $1;
        std::string type = left->get_type();
        
        SymbolTable *class_scope = SymbolTable::class_lookup(type, classes);
        if (class_scope == nullptr) {
            std::cout << yylineno << ": Type " << type << " is not a class" << std::endl;
            exit(1);
        }
        
        IdInfo *member = class_scope->lookup(*$3);
        if(member == nullptr)
        {
            std::cout << yylineno << ": " << "Class " << type << ' ' << "does not have member: " << *$3;
            exit(1);
        }
        
        ASTnode* memberNode = new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$3)), nullptr, new std::string("STRING"));
        $$ = new ASTnode(left, Data(TYPE::CHAR, OP::DOT_), memberNode, new std::string(member->type));
    }
;

assignment:
    lvalue ASSIGN_OP expression
    {
        std::string ltype = $1->get_type();
        std::string rtype = $3->get_type();
        
        
        if (ltype != rtype) {
             if(!(ltype == "BOOL" && rtype == "INT")) {
                 if (rtype != "VOID") {
                    std::cout << yylineno << ": Type mismatch in assignment: '" << ltype << "' = '" << rtype << "'" << std::endl;
                    exit(1);
                 }
             }
        }
        
        $$ = new ASTnode($1, Data(TYPE::CHAR, ASSIGN_), $3, new std::string(ltype));
    }
;

print_stmt:
    KEYWORD_PRINT OPEN_ROUND_PAR expression CLOSED_ROUND_PAR SEMICOLON
    {
        $$ = new ASTnode($3 , Data(TYPE::CHAR , PRINT) , nullptr , $3 -> get_type_ptr());
    }
;

func_call:
    ID OPEN_ROUND_PAR call_args CLOSED_ROUND_PAR
    { 
        IdInfo *id_info = currentScope -> lookup(*$1);
        bool is_constructor = false;
        
        if (id_info && id_info->category == "class") {
            is_constructor = true;
        } else if (id_info == nullptr) {
            if (SymbolTable::getClass(*$1)) is_constructor = true;
            else {
                 std::cout << yylineno << ": " << "Function or Class '" << *$1 << "' does not exist";
                 exit(1);
            }
        }
        
        if(is_constructor)
        {
             SymbolTable* classScope = SymbolTable::getClass(*$1);
             if (!classScope) {
                  std::cout << yylineno << ": " << "Class '" << *$1 << "' not found";
                  exit(1);
             }
             ASTnode* classNameNode = new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$1)), nullptr, new std::string("STRING"));
             $$ = new ASTnode(classNameNode, Data(TYPE::CHAR, OP::NEW_), nullptr, new std::string(*$1));
        } else {
             std::vector<std::string> argTypes;
             for (auto arg : *$3) {
                 argTypes.push_back(arg->get_type());
             }
             check_func_parameters(*$1 , id_info -> param , argTypes);
             
             ASTnode* argsTree = nullptr;
             if ($3->size() > 0) {
                 for (int i = $3->size() - 1; i >= 0; --i) {
                     ASTnode* arg = (*$3)[i];
                     argsTree = new ASTnode(arg, Data(TYPE::CHAR, OP::SEQ_), argsTree, new std::string("ARGS"));
                 }
             }
             
             ASTnode* funcNode = new ASTnode(nullptr, Data(TYPE::ID_INFO, id_info), nullptr, new std::string(id_info->type));
             $$ = new ASTnode(funcNode, Data(TYPE::CHAR, OP::CALL_), argsTree, new std::string(id_info->return_type));
        }
    }
    | lvalue DOT ID OPEN_ROUND_PAR call_args CLOSED_ROUND_PAR
    {
        ASTnode* obj = $1;
        std::string objType = obj->get_type();
        SymbolTable* cls = SymbolTable::getClass(objType);
        IdInfo* method = cls->lookup(*$3);
        
        std::vector<std::string> argTypes;
        for (auto arg : *$5) argTypes.push_back(arg->get_type());
        check_func_parameters(*$3, method->param, argTypes);
        
        ASTnode* memberNode = new ASTnode(nullptr, Data(TYPE::STRING, new std::string(*$3)), nullptr, new std::string("STRING"));
        ASTnode* dotNode = new ASTnode(obj, Data(TYPE::CHAR, OP::DOT_), memberNode, new std::string(method->type));
        
        ASTnode* argsTree = nullptr;
         if ($5->size() > 0) {
             for (int i = $5->size() - 1; i >= 0; --i) {
                 ASTnode* arg = (*$5)[i];
                 argsTree = new ASTnode(arg, Data(TYPE::CHAR, OP::SEQ_), argsTree, new std::string("ARGS"));
             }
         }
         
        $$ = new ASTnode(dotNode, Data(TYPE::CHAR, OP::CALL_), argsTree, new std::string(method->return_type));
    }
;

call_args:
    {
        $$ = new std::vector<ASTnode*>();
    }
    | expression_base
    {
        $$ = new std::vector<ASTnode*>();
        $$->push_back($1);
    }
    | call_args COMMA expression_base
    {
        $$ = $1;
        $$->push_back($3);
    }
;

expression:
    expression_base { $$ = $1; }
;

expression_base:
      expression_base ADD_OP expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR , OP::ADD_) , $3 , $1 -> get_type_ptr());
    }
    | expression_base SUB_OP expression_base
    {
         check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::SUB_) , $3 , $1 -> get_type_ptr());
    }
    | expression_base MUL_OP expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::MUL_) , $3 , $1 -> get_type_ptr());
    }
    | expression_base DIV_OP expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::DIV_) , $3 , $1 -> get_type_ptr());
    }
    | expression_base OP_AND expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_AND) , $3 , $1 -> get_type_ptr());
    }
    | expression_base OP_OR expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_OR) , $3 , $1 -> get_type_ptr());
    }
    | expression_base LT_OP expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::LT_) , $3 , new std::string("BOOL"));
    }
    | expression_base GT_OP expression_base
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::GT_) , $3 , new std::string("BOOL"));
    }
    | expression_base EQ_OP expression_base 
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::EQ_) , $3 , new std::string("BOOL"));
    }
    | OPEN_ROUND_PAR expression_base CLOSED_ROUND_PAR {$$ = $2;}
    | lvalue { $$ = $1; } 
    | func_call { $$ = $1; }
    | INT_CONST {$$ = new ASTnode(nullptr , Data(TYPE::INT , $1) , nullptr , new std::string("INT"));}
    | BOOL_CONST {$$ = new ASTnode(nullptr , Data(TYPE::BOOL , (bool)$1) , nullptr , new std::string("BOOL"));}
    | FLOAT_CONST {$$ = new ASTnode(nullptr , Data(TYPE::FLOAT , $1) , nullptr , new std::string("FLOAT"));}
    | STRING_CONST {$$ = new ASTnode(nullptr , Data(TYPE::STRING , $1) , nullptr , new std::string("STRING"));}
    
    | NOT_OP expression_base
    {
        $$ = new ASTnode($2 , Data(TYPE::CHAR, OP::NOT_) , nullptr , new std::string("BOOL"));
    }
    | SUB_OP expression_base %prec UMINUS
    {
         $$ = new ASTnode($2 , Data(TYPE::CHAR, OP::UMINUS_) , nullptr , $2->get_type_ptr());
    }
;

type_specifier:
    TYPE { $$ = $1; }
    | ID 
    {
        SymbolTable *class_scope = SymbolTable::class_lookup(*$1 , classes);
        if(class_scope == nullptr && *$1 != "INT" && *$1 != "FLOAT" && *$1 != "STRING" && *$1 != "BOOL" && *$1 != "VOID" && *$1 != "STR")
        {
             
            std::cout << yylineno << ": " << "Invalid type declared: " << *$1 << '\n';
            exit(1);
        } 
        if (*$1 == "STR") $$ = new std::string("STRING");
        else $$ = $1; 
    }
;

%%

extern char* yytext;
void yyerror(const char *s) {
    std::cerr << "Syntax Error at line " << yylineno << ": " << s << " at token '" << yytext << "'" << std::endl;
    exit(1);
}

int main() {
    if (yyparse() == 0) {
        std::cout << "Parsing successful!" << std::endl;
    }
    return 0;
}