%code requires {
    #include <iostream>
    #include <string>
    #include <cstring>
    #include <vector>
    #include "SymbolTable.h"
    #include "helper.h"
    #include "AbstractSyntaxTree.h"
}

%{
    #include <iostream>
    #include <string>
    #include <cstring>
    #include <vector>
    #include <fstream>
    #include "SymbolTable.h"
    #include "helper.h"
    #include "AbstractSyntaxTree.h"

    #define YYDEBUG 1 
    
    extern int yylex();
    extern int yylineno;
    void yyerror(const char *s);

    SymbolTable* currentScope = nullptr , *globalScope = nullptr;
    std::map < std::string , SymbolTable* > classes;
   
%}

%union {
    int val_int;
    float val_float;
    std::string* Str;
    std::vector<ParamInfo>* Params;
    std::vector < std::string > *params_type;
    ASTnode *node;
}

/* Token-uri È™i Tipuri */
%token <Str> ID TYPE
%token <val_int> INT_CONST BOOL_CONST
%token <val_float> FLOAT_CONST
%token <Str> STRING_CONST
%token KEYWORD_CLASS KEYWORD_FUNC KEYWORD_IF KEYWORD_MAIN KEYWORD_RETURN KEYWORD_WHILE KEYWORD_FOR KEYWORD_PRINT KEYWORD_DEFINE KEYWORD_THEN KEYWORD_CONSTR
%token ADD_OP SUB_OP MUL_OP DIV_OP ASSIGN_OP MOD_OP EQ_OP NEQ_OP LT_OP GT_OP GEQ_OP LEQ_OP
%token OP_AND OP_OR OP_BIT_AND OP_BIT_OR OP_BIT_XOR OP_BIT_LSHIFT OP_BIT_RSHIFT NOT_OP
%token OPEN_ROUND_PAR CLOSED_ROUND_PAR OPEN_RECTANGLE_PAR CLOSED_RECTANGLE_PAR
%token OPEN_CURLY_BRACE CLOSED_CURLY_BRACE SEMICOLON DOT COMMA DOLLA_SIGN

%type <Str> type_specifier
%type <Params> func_params
%type <node> expression
%type < node >  func_call
%type < params_type > call_args
%type < node > assignment 
%type < node > statement
%type < node > print_stmt

%right ASSIGN_OP
%left OP_OR
%left OP_AND
%left OP_BIT_OR
%left OP_BIT_XOR
%left OP_BIT_AND
%left EQ_OP NEQ_OP
%left LT_OP GT_OP GEQ_OP LEQ_OP
%left OP_BIT_LSHIFT OP_BIT_RSHIFT
%left ADD_OP SUB_OP
%left MUL_OP DIV_OP MOD_OP
%right NOT_OP UMINUS
%left DOT OPEN_RECTANGLE_PAR OPEN_ROUND_PAR
%left COMMA 

%start program

%%

program:
    { 
        currentScope = globalScope = new SymbolTable("Global"); 
        //Data data(TYPE::INT , 10);
        yylineno = 1;
    } global_declarations main_block
;

global_declarations:
    | global_declarations class_decl
    | global_declarations func_decl
    | global_declarations variable_decl
;

class_decl:
    KEYWORD_DEFINE KEYWORD_CLASS ID 
    { 
        SymbolTable *class_scope = SymbolTable::class_lookup(*$3 , classes);

        if(class_scope != nullptr)
        {
            std::cout << yylineno << ": " << "Class already defined: " << *$3;
            exit(1);
        }

        currentScope->addVar("class", *$3, "class", nullptr);
        currentScope = new SymbolTable(*$3, currentScope);
        classes[*$3] = currentScope;
    }
    OPEN_CURLY_BRACE class_body CLOSED_CURLY_BRACE
    { 
        currentScope = currentScope->getParent();
    }
;

class_body:
    /* gol */
    | class_body field_decl
    | class_body method_decl
    | class_body constructor_decl
;

constructor_decl:
    KEYWORD_DEFINE KEYWORD_CONSTR ID OPEN_ROUND_PAR func_params CLOSED_ROUND_PAR
    {
        if (*$3 != currentScope->get_scope_name()) {
             std::cout << yylineno << ": " << "Constructor name must match class name: " << *$3;
             exit(1);
        }
        currentScope->addVar("VOID", *$3, "constructor", $5);
        currentScope = new SymbolTable(*$3, currentScope);
        if ($5) {
           for (const auto& param : *$5) {
               currentScope->addVar(param.type, param.name, "param", nullptr);
           }
        }
    }
    function_body
    {
        currentScope = currentScope->getParent();
    }
;

field_decl:
    KEYWORD_DEFINE type_specifier ID SEMICOLON
    { 
        currentScope->addVar(*$2, *$3, "field", nullptr);
    }
;

method_decl:
    KEYWORD_DEFINE KEYWORD_FUNC type_specifier ID OPEN_ROUND_PAR func_params CLOSED_ROUND_PAR
    { 
        currentScope->addVar(*$3, *$4, "function", $6);
        currentScope = new SymbolTable(*$4, currentScope);
        if ($6) {
           for (const auto& param : *$6) {
               currentScope->addVar(param.type, param.name, "param", nullptr);
           }
        }
    }
    function_body 
    { 
        currentScope = currentScope->getParent();
    }
;

func_decl:
    KEYWORD_DEFINE KEYWORD_FUNC type_specifier ID OPEN_ROUND_PAR func_params CLOSED_ROUND_PAR
    { 
        currentScope->addVar(*$3, *$4, "function", $6);
        currentScope = new SymbolTable(*$4, currentScope);
        if ($6) {
           for (const auto& param : *$6) {
               currentScope->addVar(param.type, param.name, "param", nullptr);
           }
        }
    }
    function_body 
    { 
        currentScope = currentScope->getParent();
    }
;

func_params:
    { $$ = new std::vector<ParamInfo>(); }
    |
    type_specifier DOLLA_SIGN ID
    {
        $$ = new std::vector<ParamInfo>();
        $$->push_back(ParamInfo(*$1, *$3));
    }
    |
    func_params COMMA type_specifier DOLLA_SIGN ID
    {
        $$ = $1;
        $$->push_back(ParamInfo(*$3, *$5));
    }
;
main_block:
    KEYWORD_MAIN 
    { 
        currentScope = new SymbolTable("main", currentScope);
    }
    statement_block
    { 
        currentScope = currentScope->getParent();
    }
;


function_body:
    OPEN_CURLY_BRACE function_item_list CLOSED_CURLY_BRACE
;

function_item_list:
    | function_item_list function_item
;

function_item:
    variable_decl
    | statement
;

statement_block:
    OPEN_CURLY_BRACE statement_list CLOSED_CURLY_BRACE
;

statement_list:
    | statement_list statement
;



variable_decl:
    KEYWORD_DEFINE type_specifier ID SEMICOLON
    { 
        currentScope->addVar(*$2, *$3, "variable", nullptr);
    }
;



statement:
    assignment SEMICOLON
    {
        if(currentScope -> get_scope_name() == "main")
        {
            $1 -> evaluate();
        }

        $$ = $1;
    }
    | KEYWORD_IF expression KEYWORD_THEN statement_block {$$ = nullptr;}
    | KEYWORD_WHILE expression statement_block {$$ = nullptr;}
    | KEYWORD_FOR assignment SEMICOLON expression SEMICOLON assignment statement_block {$$ = nullptr;}
    | KEYWORD_RETURN expression SEMICOLON {$$ = nullptr;}
    | print_stmt 
    {
        if(currentScope -> get_scope_name() == "main")
        {
            Data print_result = $1 -> evaluate();

            if(print_result.type == INT) std::cout << print_result.get_int() << '\n';
            if(print_result.type == FLOAT) std::cout << print_result.get_float() << '\n';
            if(print_result.type == STRING) std::cout << *print_result.get_string() << '\n';
            if(print_result.type == BOOL) std::cout << print_result.get_bool() << '\n';
        }
        
        $$ = $1;
    }
    | func_call SEMICOLON {$$ = nullptr;}
    | statement_block {$$ = nullptr;}
;

assignment:
    ID ASSIGN_OP expression
    {
        IdInfo *id_info = currentScope -> lookup(*$1);

        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$1;
            exit(1);
        }

        if(id_info -> type != $3 -> get_type())
        {
            if(!(id_info -> type == "BOOL" && $3 -> get_type() == "INT"))
            {
                std::cout << yylineno << ": " << "Casting not allowed between " << id_info -> type << " and " << $3 -> get_type();
                exit(1);
            }
        }

        ASTnode *id_astnode = new ASTnode(nullptr , Data(TYPE::ID_INFO , id_info) , nullptr , $3 -> get_type_ptr());
        $$ = new ASTnode(id_astnode , Data(TYPE::CHAR , ASSIGN_) , $3 , $3 -> get_type_ptr());
    }
    | ID DOT ID ASSIGN_OP expression
    {
        IdInfo *id_info = currentScope -> lookup(*$1);
        
        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$1;
            exit(1);
        }

        IdInfo *id_class = globalScope -> lookup(id_info -> type);

        if(id_class == nullptr)
        {
            std::cout << yylineno << ": " << "Type not a class: " << id_info -> type;
            exit(1);
        }
        else if(id_class -> category != "class")
        {
            std::cout << yylineno << ": " << "Type not a class: " << id_info -> type;
            exit(1);
        }

        SymbolTable *class_scope = SymbolTable::class_lookup(id_info -> type , classes);
        IdInfo *submember = class_scope -> lookup(*$3);

        if(submember == nullptr)
        {
            std::cout << yylineno << ": " << "Class " << id_info -> type << ' ' << "does not have member: " << *$3;
            exit(1);
        }

        if(submember -> type != $5 -> get_type())
        {
            std::cout << yylineno << ": " << "Casting not allowed between " << submember -> type << " and " << $5 -> get_type();
            exit(1);
        }

        ASTnode *id_astnode = new ASTnode(nullptr , Data(TYPE::ID_INFO , submember) , nullptr , $5 -> get_type_ptr());
        $$ = new ASTnode(id_astnode , Data(TYPE::CHAR , ASSIGN_) , $5 , $5 -> get_type_ptr());
    }
;

print_stmt:
    KEYWORD_PRINT OPEN_ROUND_PAR expression CLOSED_ROUND_PAR SEMICOLON
    {
        $$ = new ASTnode($3 , Data(TYPE::CHAR , PRINT) , nullptr , $3 -> get_type_ptr());
    }
;

func_call:
    ID OPEN_ROUND_PAR call_args CLOSED_ROUND_PAR
    {
        IdInfo *id_info = currentScope -> lookup(*$1);

        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Function: " << *$1 << " does not exist";
            exit(1);
        }

        if (id_info->category == "class") {
             SymbolTable *class_scope = SymbolTable::class_lookup(*$1, classes);
             IdInfo *constr = class_scope->lookup(*$1);
             
             if (constr != nullptr && constr->category == "constructor") {
                  check_func_parameters(*$1, constr->param, *$3);
             } else {
                  if ($3->size() > 0) {
                       std::cout << yylineno << ": " << "No matching constructor for class " << *$1;
                       exit(1);
                  }
             }
             $$ = new ASTnode(nullptr, Data(TYPE::INT, 0), nullptr, new std::string(*$1));
        } else {
             check_func_parameters(*$1 , id_info -> param , *$3);
             $$ = new ASTnode(nullptr, Data(TYPE::INT, 0), nullptr, new std::string(id_info->return_type));
        }
    }
    | ID DOT ID OPEN_ROUND_PAR call_args CLOSED_ROUND_PAR
    {
        IdInfo *id_info = currentScope -> lookup(*$1);
        
        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$1;
            exit(1);
        }

        IdInfo *id_class = globalScope -> lookup(id_info -> type);

        if(id_class == nullptr)
        {
            std::cout << yylineno << ": " << "Type not a class: " << id_info -> type;
            exit(1);
        }
        else if(id_class -> category != "class")
        {
            std::cout << yylineno << ": " << "Type not a class: " << id_info -> type;
            exit(1);
        }

        SymbolTable *class_scope = SymbolTable::class_lookup(id_info -> type , classes);
        IdInfo *submember = class_scope -> lookup(*$3);

        if(submember == nullptr)
        {
            std::cout << yylineno << ": " << "Class " << id_info -> type << ' ' << "does not have member: " << *$3;
            exit(1);
        }
        else if(submember -> category != "function")
        {
            std::cout << yylineno << ": " << "Class " << id_info -> type << ' ' << "does not have function called: " << *$3;
        }


        check_func_parameters(*$3 , submember -> param , *$5);
        $$ = new ASTnode(nullptr, Data(TYPE::INT, 0), nullptr, new std::string(submember->return_type));
    }
;

call_args:
    {
        std::vector < std::string > *result = new std::vector < std::string >;
        $$ = result;
    }
    |
    expression 
    {
        std::vector < std::string > *result = new std::vector < std::string >;
        result -> push_back($1 -> get_type());
        $$ = result;
    }
    | call_args COMMA expression
    {
        std::vector < std::string > *result = $1;
        result -> push_back($3 -> get_type());
        $$ = result;
    }
;

expression:
    expression ADD_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR , OP::ADD_) , $3 , $1 -> get_type_ptr());
    }
    | expression SUB_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::SUB_) , $3 , $1 -> get_type_ptr());
    }
    | expression MUL_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::MUL_) , $3 , $1 -> get_type_ptr());
    }
    | expression DIV_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::DIV_) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_AND expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_AND) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_OR expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_OR) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_BIT_OR expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_BIT_OR) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_BIT_XOR expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_BIT_XOR) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_BIT_AND expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_BIT_AND) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_BIT_LSHIFT expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_BIT_LSHIFT) , $3 , $1 -> get_type_ptr());
    }
    | expression OP_BIT_RSHIFT expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::_BIT_RSHIFT) , $3 , $1 -> get_type_ptr());
    }
    | expression MOD_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::MOD_) , $3 , $1 -> get_type_ptr());
    }
    | expression LT_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::LT_) , $3 , new std::string("BOOL"));
    }
    | expression GT_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::GT_) , $3 , new std::string("BOOL"));
    }
    | expression LEQ_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::LEQ_) , $3 , new std::string("BOOL"));
    }
    | expression GEQ_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::GEQ_) , $3 , new std::string("BOOL"));
    }
    | expression NEQ_OP expression
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::NEQ_) , $3 , new std::string("BOOL"));
    }
    | expression EQ_OP expression 
    {
        check_matching_types($1 -> get_type() , $3 -> get_type());
        $$ = new ASTnode($1 , Data(TYPE::CHAR, OP::EQ_) , $3 , new std::string("BOOL"));
    }
    | OPEN_ROUND_PAR expression CLOSED_ROUND_PAR {$$ = $2;}
    | ID 
    {
        IdInfo *id_info = currentScope -> lookup(*$1);

        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$1;
            exit(1);
        }

        $$ = new ASTnode(nullptr , Data(TYPE::ID_INFO , id_info) , nullptr , new std::string(id_info -> type));
    }
    | DOLLA_SIGN ID 
    {
        IdInfo *id_info = currentScope -> lookup(*$2);

        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$2;
            exit(1);
        }

        if(id_info -> category != "param")
        {
            std::cout << yylineno << ": " << "Variable not a parameter: " << *$2;
            exit(1);
        }

        $$ = new ASTnode(nullptr , Data(TYPE::ID_INFO , id_info) , nullptr , new std::string(id_info -> type));
    }
    | INT_CONST {$$ = new ASTnode(nullptr , Data(TYPE::INT , $1) , nullptr , new std::string("INT"));}
    | BOOL_CONST {$$ = new ASTnode(nullptr , Data(TYPE::BOOL , (bool)$1) , nullptr , new std::string("BOOL"));}
    | FLOAT_CONST {$$ = new ASTnode(nullptr , Data(TYPE::FLOAT , $1) , nullptr , new std::string("FLOAT"));}
    | STRING_CONST {$$ = new ASTnode(nullptr , Data(TYPE::STRING , $1) , nullptr , new std::string("STRING"));}
    | func_call {$$ = $1;}
    | ID DOT ID 
    {
        IdInfo *id_info = currentScope -> lookup(*$1);
        
        if(id_info == nullptr)
        {
            std::cout << yylineno << ": " << "Variable not declared in the scope: " << *$1;
            exit(1);
        }

        IdInfo *id_class = globalScope -> lookup(id_info -> type);

        if(id_class == nullptr)
        {
            std::cout << yylineno << ": " << "Type not a class: " << id_info -> type;
            exit(1);
        }
        else if(id_class -> category != "class")
        {
            std::cout << yylineno << ": " << "Type not a class: " << id_info -> type;
            exit(1);
        }

        SymbolTable *class_scope = SymbolTable::class_lookup(id_info -> type , classes);
        IdInfo *submember = class_scope -> lookup(*$3);

        if(submember == nullptr)
        {
            std::cout << yylineno << ": " << "Class " << id_info -> type << ' ' << "does not have member: " << *$3;
            exit(1);
        }

       // $$ = new std::string(submember -> type);
        $$ = new ASTnode(nullptr , Data(TYPE::ID_INFO , submember) , nullptr , new std::string(submember -> type));

    }
    | NOT_OP expression 
    {
        if ($2->get_type() != "BOOL")
        {
             std::cout << yylineno << ": " << "Type mismatch: NOT operator requires BOOL, got " << $2->get_type();
             exit(1);
        }
        $$ = new ASTnode($2 , Data(TYPE::CHAR, OP::NOT_) , nullptr , new std::string("BOOL"));
    }
    | SUB_OP expression %prec UMINUS
    {
        if ($2->get_type() != "INT" && $2->get_type() != "FLOAT")
        {
             std::cout << yylineno << ": " << "Type mismatch: Unary Minus operator requires INT or FLOAT, got " << $2->get_type();
             exit(1);
        }
        $$ = new ASTnode($2 , Data(TYPE::CHAR, OP::UMINUS_) , nullptr , $2->get_type_ptr());
    }
;

type_specifier:
    TYPE { $$ = $1; }
    | ID 
    {
        SymbolTable *class_scope = SymbolTable::class_lookup(*$1 , classes);
       
        if(class_scope == nullptr && *$1 != "INT" && *$1 != "FLOAT" && *$1 != "STRING" && *$1 != "BOOL")
        {
            std::cout << yylineno << ": " << "Invalid type declared: " << *$1 << '\n';
            exit(1);
        } 

        $$ = $1; 
    }
;

%%

void yyerror(const char *s) {
    std::cerr << "Syntax Error at line " << yylineno << ": " << s << std::endl;
    exit(1);
}

int main() {
    // yydebug = 1; 
    if (yyparse() == 0) {
        std::cout << "Parsing successful!" << std::endl;
        
        std::ofstream outFile("tables.txt");
        const auto& tables = SymbolTable::getAllTables();
        for (auto table : tables) {
            table->print(outFile);
        }
        outFile.close();
        std::cout << "Symbol tables written to tables.txt" << std::endl;
    }
    return 0;
}